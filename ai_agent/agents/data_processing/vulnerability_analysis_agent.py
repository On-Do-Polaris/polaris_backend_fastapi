'''
파일명: vulnerability_analysis_agent.py
작성일: 2025-12-08
버전: v03
파일 개요: 건축물 대장 기반 물리적 취약성 정밀 분석 에이전트

역할:
    - BuildingDataFetcher를 통해 실시간 건축물 정보 및 지리 정보 수집
    - 데이터 기반의 물리적 취약성(Vulnerability) 및 회복력(Resilience) 요인 도출
    - LLM을 활용한 정성적 분석 리포트 생성
변경 이력:
    - 2025-12-08: v01 - 초기 생성
    - 2025-12-08: v02 - BuildingDataFetcher의 fetch_full_tcfd_data 활용, 분석 및 LLM 프롬프트 강화
    - 2025-12-08: v03 - 층별 용도 텍스트 LLM 해석 지시 추가
'''

from typing import Dict, Any, List, Optional
import logging
from datetime import datetime
import json # for pretty printing data to LLM

# BuildingDataFetcher 임포트
try:
    from ...utils.building_data_fetcher import BuildingDataFetcher
except ImportError:
    BuildingDataFetcher = None
    print("⚠️ BuildingDataFetcher를 임포트할 수 없습니다.")

logger = logging.getLogger(__name__)


class VulnerabilityAnalysisAgent:
    """
    건축물 물리적 취약성 정밀 분석 에이전트
    """

    def __init__(self, llm_client=None):
        """
        초기화
        :param llm_client: LLM 클라이언트 인스턴스 (텍스트 생성용)
        """
        self.logger = logger
        self.llm_client = llm_client
        
        if BuildingDataFetcher:
            try:
                self.fetcher = BuildingDataFetcher()
                self.logger.info("BuildingDataFetcher 초기화 성공")
            except Exception as e:
                self.logger.error(f"BuildingDataFetcher 초기화 실패: {e}")
                self.fetcher = None
        else:
            self.fetcher = None

    def analyze(self, lat: float, lon: float, address: str = None, risk_scores: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        위치 기반 취약성 분석 수행
        
        :param lat: 위도
        :param lon: 경도
        :param address: (선택) 도로명 주소 - 제공 시 더 정확한 데이터 조회 가능
        :param risk_scores: (선택) 외부에서 계산된 리스크 점수 딕셔너리
        :return: 분석 결과 (데이터, 취약/회복 요인, 리포트)
        """
        self.logger.info(f"취약성 분석 시작: lat={lat}, lon={lon}, address={address}")
        
        # 1. 데이터 수집 (fetch_full_tcfd_data 활용)
        building_data = self._fetch_data(lat, lon, address)
        
        # 2. 요인 분석
        vulnerabilities = self._identify_vulnerabilities(building_data)
        resilience = self._identify_resilience(building_data)
        
        # 3. 구조적 등급 평가
        structural_grade = self._evaluate_structural_grade(building_data)
        
        # 4. LLM 리포트 생성
        report = self._generate_llm_report(
            building_data, 
            vulnerabilities, 
            resilience, 
            structural_grade, 
            risk_scores
        )
        
        result = {
            "meta": {
                "analyzed_at": datetime.now().isoformat(),
                "location": {"lat": lat, "lon": lon},
                "data_source": "Architectural HUB API (TCFD Enhanced)" if self.fetcher else "Fallback Data"
            },
            "building_data": building_data,
            "structural_grade": structural_grade,
            "vulnerabilities": vulnerabilities,
            "resilience": resilience,
            "analysis_report": report
        }
        
        self.logger.info("취약성 분석 완료")
        return result

    def _fetch_data(self, lat: float, lon: float, address: str = None) -> Dict[str, Any]:
        """BuildingDataFetcher를 통한 TCFD 데이터 조회"""
        if not self.fetcher:
            self.logger.warning("Fetcher 없음, 빈 데이터 반환")
            return {}
            
        try:
            # fetch_full_tcfd_data는 에러를 내부적으로 처리하고 Fallback 값을 반환함
            data = self.fetcher.fetch_full_tcfd_data(lat, lon, address)
            return data
        except Exception as e:
            self.logger.error(f"TCFD 데이터 조회 중 오류: {e}")
            return {}

    def _identify_vulnerabilities(self, data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """취약성 요인 식별 로직 (TCFD 데이터 기반 강화)"""
        factors = []
        
        if not data:
            return factors

        physical_specs = data.get('physical_specs', {})
        floor_details = data.get('floor_details', [])
        geo_risks = data.get('geo_risks', {})

        # 1. 노후도 (Aging)
        age = physical_specs.get('age', {}).get('years', 0)
        if age >= 40:
            factors.append({
                "category": "Structural",
                "factor": "심각한 노후화",
                "severity": "Very High",
                "description": f"준공 {age}년차 건물로, 구조적 성능 저하 및 내구성 부족 가능성이 매우 높음"
            })
        elif age >= 30:
            factors.append({
                "category": "Structural",
                "factor": "건물 노후화",
                "severity": "High",
                "description": f"준공 {age}년차 건물로, 설비 및 마감재 노후화 진행 우려"
            })

        # 2. 내진 설계 미적용/취약 (Seismic Vulnerability) - 다중 건물 집계
        seismic_info = physical_specs.get('seismic', {})
        buildings_with_design = seismic_info.get('buildings_with_design', 0)
        buildings_without_design = seismic_info.get('buildings_without_design', 0)
        total_buildings = buildings_with_design + buildings_without_design

        if total_buildings > 0:
            if buildings_without_design > buildings_with_design:
                factors.append({
                    "category": "Seismic",
                    "factor": "다수 건물 내진 설계 미적용",
                    "severity": "Very High",
                    "description": f"총 {total_buildings}개 건물 중 {buildings_without_design}개가 내진 설계 미적용 ({buildings_without_design/total_buildings*100:.1f}%)"
                })
            elif buildings_without_design > 0:
                factors.append({
                    "category": "Seismic",
                    "factor": "일부 건물 내진 설계 미적용",
                    "severity": "High",
                    "description": f"총 {total_buildings}개 건물 중 {buildings_without_design}개가 내진 설계 미적용"
                })


        # 3. 지하층 및 중요 설비 (Basement & Critical Facilities) - 다중 건물 집계
        max_underground = physical_specs.get('floors', {}).get('max_underground', 0)
        has_potential_critical_facility = False
        
        if max_underground > 0:
            factors.append({
                "category": "Flood",
                "factor": "지하층 보유 건물 존재",
                "severity": "Medium" if max_underground == 1 else "High",
                "description": f"최대 지하 {max_underground}층까지 보유한 건물이 있어 도시 침수 및 내수 범람 시 침수 피해 위험"
            })
            
            # LLM이 상세 판단하겠지만, 시스템 차원에서도 힌트가 있으면 태깅
            for floor in floor_details:
                if floor.get('type') == 'Underground' and floor.get('is_potentially_critical'):
                    has_potential_critical_facility = True
            
            if has_potential_critical_facility:
                factors.append({
                    "category": "Flood/Operational",
                    "factor": "지하 중요 설비 의심",
                    "severity": "High",
                    "description": "지하층 용도에 기계/전기 등 중요 설비 관련 키워드가 포함되어 있어 침수 시 운영 중단 위험 존재 (상세 분석 필요)"
                })
            
        # 4. 하천 인접성 (River Proximity)
        dist_river = geo_risks.get('river', {}).get('distance_m', float('inf'))
        if dist_river < 100:
            factors.append({
                "category": "Flood",
                "factor": "하천 초근접",
                "severity": "Very High",
                "description": f"하천으로부터 {dist_river:.0f}m 거리에 위치하여 범람 위험에 직접 노출"
            })
        elif dist_river < 500:
            factors.append({
                "category": "Flood",
                "factor": "하천 인접",
                "severity": "High",
                "description": f"하천으로부터 {dist_river:.0f}m 거리에 위치하여 범람 영향권에 포함"
            })
            
        # 5. 해안 인접성 (Coastal Proximity)
        dist_coast = geo_risks.get('coast_distance_m', float('inf'))
        if dist_coast < 500:
            factors.append({
                "category": "Surge",
                "factor": "해안 인접",
                "severity": "High",
                "description": f"해안선으로부터 {dist_coast:.0f}m 위치, 해일 및 염해 피해 가능성"
            })

        # 6. 필로티 구조 (Piloti) - 표제부에서 직접 '필로티'라는 필드는 없으므로 구조+층수로 추정 필요
        # 현재 fetcher에서 has_piloti를 반환하지 않으므로, 이 부분은 추후 개선
        structure = physical_specs.get('structure', '')
        ground_floors = physical_specs.get('floors', {}).get('ground', 0)
        # 임시 추정 (더 정교한 로직 필요)
        if '철근콘크리트' in structure and ground_floors >= 3 and any("주차장" in f.get('usage_main', '') for f in floor_details if f.get('floor_no') == 1):
             factors.append({
                "category": "Structural",
                "factor": "필로티 구조 (추정)",
                "severity": "High",
                "description": "구조 및 1층 용도(주차장)로 미루어 필로티 구조 추정, 지진 시 층 붕괴 위험 및 침수 취약성 존재"
            })

        return factors

    def _identify_resilience(self, data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """회복력/강점 요인 식별 로직 (TCFD 데이터 기반 강화)"""
        factors = []
        
        if not data:
            return factors
            
        physical_specs = data.get('physical_specs', {})
        transition_specs = data.get('transition_specs', {})
        floor_details = data.get('floor_details', [])

        # 1. 신축 건물
        age = physical_specs.get('age', {}).get('years', 0)
        if age < 10:
            factors.append({
                "category": "Structural",
                "factor": "최신 건축 기준 적용",
                "strength": "High",
                "description": f"준공 {age}년차 신축 건물로 최신 내진 및 소방 기준이 적용되었을 가능성 높음"
            })
            
        # 2. 내진 설계 적용 (Seismic Resilience)
        seismic_applied = physical_specs.get('seismic', {}).get('applied', 'Unknown')
        if seismic_applied == 'Y':
            factors.append({
                "category": "Seismic",
                "factor": "내진 설계 적용",
                "strength": "Very High",
                "description": "내진 설계가 적용되어 지진 및 강풍에 대한 구조적 안정성 확보"
            })
            
        # 3. 저수조 (가뭄 대응)
        has_water_tank = any('저수조' in f.get('usage_etc', '') for f in floor_details)
        if has_water_tank:
            factors.append({
                "category": "Drought",
                "factor": "저수조 보유",
                "strength": "Medium",
                "description": "비상 용수 확보 시설(저수조) 보유로 가뭄 및 단수 시 회복력 존재"
            })
            
        # 4. 견고한 구조재 (Structure Resilience)
        structure = physical_specs.get('structure', '')
        if '철근콘크리트' in structure or '철골' in structure:
             factors.append({
                "category": "Fire/Wind",
                "factor": "견고한 구조재",
                "strength": "Medium",
                "description": f"{structure} 구조로 화재 및 강풍에 대한 저항성 보유"
            })

        # 5. 에너지/친환경 건축물 (Transition Resilience)
        energy_grade = transition_specs.get('energy_grade', '')
        green_grade = transition_specs.get('green_grade', '')
        
        if energy_grade and energy_grade != '등급없음':
            factors.append({
                "category": "Transition",
                "factor": "에너지효율등급 우수",
                "strength": "High",
                "description": f"에너지효율등급 '{energy_grade}' 취득, 에너지 비용 리스크 및 탄소 배출량 저감에 유리"
            })
        if green_grade and green_grade != '등급없음':
            factors.append({
                "category": "Transition",
                "factor": "친환경 건축물 인증",
                "strength": "High",
                "description": f"친환경건축물 등급 '{green_grade}' 취득, ESG 경영 및 녹색 금융 연계 가능성 높음"
            })

        return factors

    def _evaluate_structural_grade(self, data: Dict[str, Any]) -> str:
        """TCFD 데이터 기반 구조적 안전 등급 평가 (A~E)"""
        if not data:
            return "Unknown"
            
        score = 100 # 시작점
        physical_specs = data.get('physical_specs', {})
        floor_details = data.get('floor_details', [])

        # 1. 노후도 (감점)
        age = physical_specs.get('age', {}).get('years', 0)
        score -= min(age * 1, 50) # 1년에 1점, 최대 50점 감점
        
        # 2. 내진 설계 미적용 (감점)
        seismic_applied = physical_specs.get('seismic', {}).get('applied', 'Unknown')
        if seismic_applied == 'N':
            score -= 20
        elif not physical_specs.get('seismic', {}).get('ability', ''): # 내진능력 명시 안됨
             score -= 10
            
        # 3. 필로티 구조 (감점 - 추정)
        structure = physical_specs.get('structure', '')
        ground_floors_count = physical_specs.get('floors', {}).get('ground', 0)
        is_piloti_suspected = ('철근콘크리트' in structure or '철골' in structure) and ground_floors_count >= 3 and any("주차장" in f.get('usage_main', '') for f in floor_details if f.get('floor_no') == 1)
        if is_piloti_suspected:
            score -= 15 
            
        # 4. 지하 중요 설비 (감점 - 침수 시 리스크 증폭)
        if any(f.get('type') == 'Underground' and f.get('is_potentially_critical') for f in floor_details):
            score -= 15
            
        # 5. 구조재 (가점)
        if '철근콘크리트' in structure or '철골' in structure:
            score += 10
        elif '목구조' in structure or '조적조' in structure:
            score -= 10 # 취약 구조 감점

        # 6. 저수조 보유 (가점 - 회복력)
        if any('저수조' in f.get('usage_etc', '') for f in floor_details):
            score += 5
            
        # 등급 산정
        if score >= 90: return "A (Excellent)"
        elif score >= 80: return "B (Good)"
        elif score >= 70: return "C (Fair)"
        elif score >= 60: return "D (Poor)"
        else: return "E (Very Poor)"

    def _generate_llm_report(
        self, 
        data: Dict[str, Any], 
        vulnerabilities: List[Dict], 
        resilience: List[Dict], 
        grade: str,
        risk_scores: Dict = None
    ) -> str:
        """LLM을 활용한 종합 분석 리포트 생성 (TCFD 데이터 기반 강화)"""
        
        # LLM 사용
        if self.llm_client:
            try:
                prompt = self._build_prompt(data, vulnerabilities, resilience, grade, risk_scores)
                response = self.llm_client.invoke(prompt)
                return response
            except Exception as e:
                self.logger.error(f"LLM 리포트 생성 실패: {e}")
                return self._generate_fallback_analysis(data, vulnerabilities, resilience, grade)
        
        return self._generate_fallback_analysis(data, vulnerabilities, resilience, grade)


    def _generate_fallback_analysis(
        self,
        data: Dict[str, Any], 
        vulnerabilities: List[Dict], 
        resilience: List[Dict], 
        grade: str
    ) -> str:
        """LLM 실패 시 기본 분석 생성 (TCFD 데이터 반영)"""
        summary = "## 건물 물리적 취약성 종합 분석 (자동 생성)\n\n"
        
        meta = data.get('meta', {})
        physical_specs = data.get('physical_specs', {})
        
        summary += "### 1. 건물 개요\n"
        summary += f"- **주소**: {meta.get('address', '미상')}\n"
        summary += f"- **구조/규모**: {physical_specs.get('structure', '미상')}, 지상 {physical_specs.get('floors', {}).get('ground', '?')}층/지하 {physical_specs.get('floors', {}).get('underground', '?')}층\n"
        summary += f"- **연식**: {physical_specs.get('age', {}).get('approval_date', '미상')} 준공 ({physical_specs.get('age', {}).get('years', '?')}년 경과)\n"
        summary += f"- **내진 설계 적용 여부**: {physical_specs.get('seismic', {}).get('applied', 'Unknown')} ({physical_specs.get('seismic', {}).get('ability', '')})\n"
        summary += f"- **구조 안전 등급**: **{grade}**\n"
        
        summary += "\n### 2. 주요 취약 요인\n"
        if vulnerabilities:
            for v in vulnerabilities:
                summary += f"- [{v['category']}] **{v['factor']} ({v['severity']})**: {v['description']}\n"
        else:
            summary += "- 특이할 만한 주요 취약 요인이 식별되지 않았습니다.\n"
            
        summary += "\n### 3. 주요 회복력 및 강점\n"
        if resilience:
            for r in resilience:
                summary += f"- [{r['category']}] **{r['factor']} ({r['strength']})**: {r['description']}\n"
        else:
            summary += "- 구조적/기능적 강점이 뚜렷하지 않습니다.\n"
        
        summary += "\n### 4. 종합 의견\n"
        summary += "LLM 분석 생성 실패로 시스템에서 식별된 주요 특성만을 바탕으로 간략한 요약을 제공합니다. LLM이 정상 작동할 경우 더 심층적인 분석을 제공할 수 있습니다.\n"
        
        return summary

    def _build_prompt(
        self, 
        data: Dict[str, Any], 
        vulnerabilities: List[Dict], 
        resilience: List[Dict], 
        grade: str,
        risk_scores: Dict = None
    ) -> str:
        """LLM 프롬프트 구성 (TCFD 데이터 기반 강화 + LLM 해석 위임)"""
        
        meta = data.get('meta', {})
        physical_specs = data.get('physical_specs', {})
        floor_details = data.get('floor_details', [])
        transition_specs = data.get('transition_specs', {})
        geo_risks = data.get('geo_risks', {})

        prompt = f"""당신은 건축 및 재난 리스크 분석 전문가이며, TCFD(기후변화 관련 재무 정보 공개 태스크포스) 보고서 작성을 위한 건물 물리적 취약성 분석을 수행합니다.

제공된 건축물 대장 및 지리 데이터를 바탕으로 다음 지침에 따라 심층 분석 리포트를 작성해주세요.

---
## 분석 대상 건물 상세 데이터 (Raw Data)

### 1. 메타 정보
{json.dumps(meta, indent=2, ensure_ascii=False)}

### 2. 물리적 특성 (Physical Specifications)
{json.dumps(physical_specs, indent=2, ensure_ascii=False)}

### 3. 층별 상세 정보 (Floor Details) - ⭐ 핵심 분석 대상
* `usage_main`(주용도) 및 `usage_etc`(기타용도) 텍스트를 꼼꼼히 분석하여 침수 시 위험 요소(전기실, 기계실, 방재실, 발전기 등)를 식별하세요.
* `is_potentially_critical` 플래그는 참고용 힌트일 뿐이며, 텍스트의 문맥을 고려하여 최종 판단하세요.
{json.dumps(floor_details, indent=2, ensure_ascii=False)}

### 4. 전환 특성 (Transition Specifications)
{json.dumps(transition_specs, indent=2, ensure_ascii=False)}

### 5. 지리적 리스크 (Geographical Risks)
{json.dumps(geo_risks, indent=2, ensure_ascii=False)}

---
## 시스템 분석 결과 (참고)

### 1. 식별된 주요 취약 요인
{self._format_list(vulnerabilities)}

### 2. 식별된 주요 회복력 요인
{self._format_list(resilience)}

### 3. 자체 평가 구조 안전 등급
- 등급: {grade}

"""

        if risk_scores:
            prompt += f"""
### 4. 외부 리스크 평가 점수
{self._format_dict(risk_scores)}

"""

        prompt += """
---
## 보고서 작성 지침

위의 상세 데이터를 면밀히 검토하고, 시스템 분석 결과(취약/회복 요인, 등급)를 참고하여 다음 목차에 따라 마크다운 형식으로 리포트를 작성하세요.

**핵심**: TCFD 보고서의 목적에 맞춰 **물리적 리스크가 건물의 재무적 가치, 운영 지속성, 또는 자산의 미래 가치에 어떤 영향을 미칠지**에 초점을 맞춰 분석해야 합니다. 단순한 현상 나열이 아닌, **데이터에 기반한 인과관계 분석과 그로 인한 재무/운영적 함의**를 도출해야 합니다.

**[보고서 목차]**
1.  **종합 평가 요약**: 건물의 전반적인 물리적/전환 리스크 현황 및 재무/운영적 함의를 요약.
2.  **구조적 안전성 및 노후도 분석**: 건물 구조, 연식, 내진 설계 여부를 바탕으로 극한 기후(지진, 강풍) 및 노후화 리스크 평가.
3.  **침수 및 입지 리스크 분석**: 
    - 지하층의 `usage_main`, `usage_etc` 텍스트를 분석하여, 침수 시 건물 운영에 치명적인 중요 설비(전기실, 기계실 등)가 침수될 위험이 있는지 구체적으로 서술하세요.
    - 하천/해안 인접성, 침수 이력 등을 종합하여 침수 시 예상 피해 규모 및 운영 중단 리스크를 분석하세요.
4.  **전환 리스크 및 자산 가치 영향**: 에너지 효율 등급, 친환경 건축물 인증 등 '전환 리스크' 관련 특성과 주택 가격 데이터를 연계하여 자산 가치 변동 및 미래 투자/보강 필요성 분석.
5.  **주요 제언**: 식별된 리스크를 관리하고 회복력을 강화하기 위한 구체적이고 실용적인 조치(정밀 진단, 방재 시설 설치, 친환경 설비 투자 등)를 제안.

**톤앤매너**: 전문적이고 객관적인 어조를 유지하며, 분석 결과의 재무적 중요성을 강조하세요.
"""
        return prompt

    def _format_list(self, items: List[Dict]) -> str:
        if not items: return "(없음)"
        return "\n".join([f"- **{item.get('factor')} ({item.get('category', '')})**: {item.get('description', '')} (심각도: {item.get('severity', item.get('strength', ''))})" for item in items])

    def _format_dict(self, items: Dict) -> str:
        if not items: return "(없음)"
        formatted_str = ""
        for k, v in items.items():
            if isinstance(v, dict):
                formatted_str += f"- **{k}**:\n"
                for sub_k, sub_v in v.items():
                    formatted_str += f"  - {sub_k}: {sub_v}\n"
            else:
                formatted_str += f"- {k}: {v}\n"
        return formatted_str